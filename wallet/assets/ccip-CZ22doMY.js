import{a as e,c as t,d as n,f as r,i,l as a,n as o,o as s,p as c,r as l,s as u,t as d,u as f}from"./index-4RclxVhr.js";function p(e,t){if(!f(e,{strict:!1}))throw new n({address:e});if(!f(t,{strict:!1}))throw new n({address:t});return e.toLowerCase()===t.toLowerCase()}var m=class extends r{constructor({callbackSelector:t,cause:n,data:r,extraData:i,sender:a,urls:o}){super(n.shortMessage||`An error occurred while fetching for an offchain result.`,{cause:n,metaMessages:[...n.metaMessages||[],n.metaMessages?.length?``:[],`Offchain Gateway Call:`,o&&[`  Gateway URL(s):`,...o.map(t=>`    ${e(t)}`)],`  Sender: ${a}`,`  Data: ${r}`,`  Callback selector: ${t}`,`  Extra data: ${i}`].flat(),name:`OffchainLookupError`})}},h=class extends r{constructor({result:t,url:n}){super(`Offchain gateway response is malformed. Response data must be a hex value.`,{metaMessages:[`Gateway URL: ${e(n)}`,`Response: ${s(t)}`],name:`OffchainLookupResponseMalformedError`})}},g=class extends r{constructor({sender:e,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${e}`],name:`OffchainLookupSenderMismatchError`})}};const _=`0x556f1830`,v={name:`OffchainLookup`,type:`error`,inputs:[{name:`sender`,type:`address`},{name:`urls`,type:`string[]`},{name:`callData`,type:`bytes`},{name:`callbackFunction`,type:`bytes4`},{name:`extraData`,type:`bytes`}]};async function y(e,{blockNumber:n,blockTag:r,data:i,to:o}){let{args:s}=u({data:i,abi:[v]}),[c,f,h,_,y]=s,{ccipRead:x}=e,S=x&&typeof x?.request==`function`?x.request:b;try{if(!p(o,c))throw new g({sender:c,to:o});let i=f.includes(`x-batch-gateway:true`)?await l({data:h,ccipRequest:S}):await S({data:h,sender:c,urls:f}),{data:s}=await d(e,{blockNumber:n,blockTag:r,data:a([_,t([{type:`bytes`},{type:`bytes`}],[i,y])]),to:o});return s}catch(e){throw new m({callbackSelector:_,cause:e,data:i,extraData:y,sender:c,urls:f})}}async function b({data:e,sender:t,urls:n}){let r=Error(`An unknown error occurred.`);for(let i=0;i<n.length;i++){let a=n[i],l=a.includes(`{data}`)?`GET`:`POST`,u=l===`POST`?{data:e,sender:t}:void 0,d=l===`POST`?{"Content-Type":`application/json`}:{};try{let n=await fetch(a.replace(`{sender}`,t.toLowerCase()).replace(`{data}`,e),{body:JSON.stringify(u),headers:d,method:l}),i;if(i=n.headers.get(`Content-Type`)?.startsWith(`application/json`)?(await n.json()).data:await n.text(),!n.ok){r=new o({body:u,details:i?.error?s(i.error):n.statusText,headers:n.headers,status:n.status,url:a});continue}if(!c(i)){r=new h({result:i,url:a});continue}return i}catch(e){r=new o({body:u,details:e.message,url:a})}}throw r}export{b as ccipRequest,y as offchainLookup,v as offchainLookupAbiItem,_ as offchainLookupSignature};